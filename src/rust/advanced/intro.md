# 进阶内容

### Closures 闭包


闭包可以从环境中捕获值，与函数接受参数的方式是完全一致的：获取所有权、可变借用及不可变借用，编码表现为 3 种 Trait：

- ::FnOnce::：意味着闭包可以从它的封闭作用域中，也就是闭包所处的环境中，消耗捕获的变量。为了实现这一功能，闭包必须在定义时取得这些变量的所有权并将它们移动至闭包中，因为闭包**不能多次获取并消耗同一变量的所有权，所以只能被调用一次（Once）**。
- ::FnMut::：可以从环境中可变地借用值并对它们进行修改。
- ::Fn::：可以从环境中不可变地借用值。

> 当你创建闭包时，Rust会基于闭包从环境中使用值的方式来自动推导出它需要使用的trait。所有闭包都自动实现了FnOnce，因为它们至少都可以被调用一次。那些不需要移动被捕获变量的闭包还会实现FnMut，而那些不需要对被捕获变量进行可变访问的闭包则同时实现了Fn。

> 使用 **::move::** 关键字，强制闭包获取环境中值的所有权。

### Iterator 迭代器

在Rust中，迭代器是惰性的（layzy）。这也就意味着创建迭代器后，除非你主动调用方法来消耗并使用迭代器，否则它们不会产生任何的实际效果。

> iter() | iter_into() | iter_mut()

迭代器可以让开发者专注于高层的业务逻辑，而不必陷入编写循环、维护中间变量这些具体的细节中。

运行期初始化静态变量

使用`lazy_static`在每次访问静态变量时，会有轻微的性能损失，因为其内部实现用了一个底层的并发原语`std::sync::Once`，在每次访问该变量时，程序都会执行一次原子指令用于确认静态变量的初始化是否完成

[https://github.com/rust-lang-nursery/lazy-static.rs](https://github.com/rust-lang-nursery/lazy-static.rs)
